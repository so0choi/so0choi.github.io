---
title: "[BOJ]18352. 특정 거리의 도시 찾기"
description: '문제 링크 문제 어떤 나라에는 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다. 이 때 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력하는 프로그램을 작성하시오. 또한 출발 도시 X에서 출발 도시 X로 가는 최단…'
pubDate: 2020-09-09 15:00:15
tags:
  - BFS
  - Algorithm
category: Algorithm

---


[문제 링크](https://www.acmicpc.net/problem/18352)

## 문제

어떤 나라에는 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다.

이 때 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력하는 프로그램을 작성하시오. 또한 출발 도시 X에서 출발 도시 X로 가는 최단 거리는 항상 0이라고 가정한다.

예를 들어 N=4, K=2, X=1일 때 다음과 같이 그래프가 구성되어 있다고 가정하자.

![그래프](https://upload.acmicpc.net/a5e311d7-7ce4-4638-88a5-3665fb4459e5/-/preview/)

이 때 1번 도시에서 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 2인 도시는 4번 도시 뿐이다. 2번과 3번 도시의 경우, 최단 거리가 1이기 때문에 출력하지 않는다.

## 입력

첫째 줄에 도시의 개수 **N**, 도로의 개수 **M**, 거리 정보 **K**, 출발 도시의 번호 **X**가 주어진다. (2 ≤ N ≤ 300,000, 1 ≤ M ≤ 1,000,000, 1 ≤ K ≤ 300,000, 1 ≤ X ≤ N) 둘째 줄부터 M개의 줄에 걸쳐서 두 개의 자연수 A, B가 공백을 기준으로 구분되어 주어진다. 이는 A번 도시에서 B번 도시로 이동하는 단방향 도로가 존재한다는 의미다. (1 ≤ A, B ≤ N) 단, A와 B는 서로 다른 자연수이다.

## 출력

X로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 K인 모든 도시의 번호를 한 줄에 하나씩 오름차순으로 출력한다.

이 때 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 **-1**을 출력한다.

### 예제 입출력

입력 1

```
# 입력
4 4 2 1
1 2
1 3
2 3
2 4
# 출력
4
```

입력 2

```
# 입력
4 3 2 1
1 2
1 3
1 4
# 출력
-1
```

입력 3

```
# 입력
4 4 1 1
1 2
1 3
2 3
2 4
# 출력
2
3
```

## 풀이

각 간선의 비용이 `1`이므로 BFS를 이용해 `O(N+M)`을 만족시키는 코드를 작성해 풀 수 있다.
_간선의 비용이 모두 다를 경우 '다익스트라' 알고리즘을 사용해야 한다!_
단방향 그래프인점을 유의해 인접리스트 형식으로 그래프 데이터를 입력받는다.

```python
for _ in range(m):
    a,b = map(int,input().split())
    city[a].append(b)
```

출발점으로부터 각 간선까지의 거리를 저장하는 리스트 `distance`를 생성하고 `-1`로 초기화 한다.
그리고 큐에 출발점을 넣고 탐색을 시작한다.

내가 잘못 생간했던 부분은 큐에서 거리를 계산할 때 거리가 `k`인 정점을 찾으면 탐색을 종료해도 된다고 생각했던 것이다. BFS 탐색 이므로 전체 정점에 대한 탐색을 해야 거리가 `K`인 정점을 모두 찾을 수 있었다.

## 소스 코드

```python
from collections import deque
import sys
n,m,k,x = map(int,input().split())
city = [[] for _ in range(n+1)]
for _ in range(m):
    a,b = map(int,input().split())
    city[a].append(b)
q = deque([x])
distance = [-1]*(n+1)
distance[x] = 0

while q:
    cur = q.popleft()
    for c in city[cur]:
        if distance[c]==-1:
            q.append(c)
            distance[c] = distance[cur]+1
for i in range(1,n+1):
    if distance[i] == k:
        print(i)
else:
    print(-1)
```
